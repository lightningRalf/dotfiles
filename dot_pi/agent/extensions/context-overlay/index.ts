import { stat } from "node:fs/promises";
import { dirname, isAbsolute, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { buildSessionContext, type ExtensionAPI } from "@mariozechner/pi-coding-agent";
import { ContextOverlayComponent } from "./context-overlay-component.js";
import { ContextSnapshotStore } from "./snapshot-store.js";

const baseDir = dirname(fileURLToPath(import.meta.url));

const stripAtPrefix = (path: string): string => (path.startsWith("@") ? path.slice(1) : path);

const resolveEditorCommand = (): string[] => {
	const rawEditor = (process.env.VISUAL ?? process.env.EDITOR ?? "vi").trim();
	const parts = rawEditor.split(/\s+/).filter((part) => part.length > 0);
	return parts.length > 0 ? parts : ["vi"];
};

export default function contextOverlayExtension(pi: ExtensionAPI): void {
	const store = new ContextSnapshotStore();

	pi.on("before_agent_start", (event) => {
		store.onBeforeAgentStart(event.systemPrompt);
	});

	pi.on("context", (event, ctx) => {
		store.onContext(event.messages);
		store.onUsage(ctx.getContextUsage());
	});

	pi.on("turn_end", (_event, ctx) => {
		store.onUsage(ctx.getContextUsage());
	});

	pi.on("session_switch", () => {
		store.onSessionReset();
	});

	pi.on("session_tree", () => {
		store.onSessionReset();
	});

	pi.on("session_compact", () => {
		store.onSessionReset();
	});

	pi.on("resources_discover", () => {
		return {
			promptPaths: [resolve(baseDir, "context-report.md")],
		};
	});

	pi.registerCommand("c", {
		description: "Open context inspector overlay",
		handler: async (_args, ctx) => {
			if (!ctx.hasUI) return;

			// Refresh snapshot from current session state so /c always shows live values,
			// even right after /reload or before the next model turn.
			const liveSessionContext = buildSessionContext(ctx.sessionManager.getEntries(), ctx.sessionManager.getLeafId());
			store.onContext(liveSessionContext.messages);
			store.onBeforeAgentStart(ctx.getSystemPrompt());
			store.onUsage(ctx.getContextUsage());

			const openPathInZellij = async (rawPath: string): Promise<boolean> => {
				if (!process.env.ZELLIJ) {
					ctx.ui.notify("Not running inside zellij session", "error");
					return false;
				}

				const normalized = stripAtPrefix(rawPath.trim());
				const filePath = isAbsolute(normalized) ? normalized : resolve(ctx.cwd, normalized);

				let fileStat: Awaited<ReturnType<typeof stat>>;
				try {
					fileStat = await stat(filePath);
				} catch {
					ctx.ui.notify(`Path does not exist: ${filePath}`, "error");
					return false;
				}

				if (!fileStat.isFile()) {
					if (fileStat.isDirectory()) {
						ctx.ui.notify(`Path is a directory, not a file: ${filePath}`, "warning");
					} else {
						ctx.ui.notify(`Path is not a regular file: ${filePath}`, "warning");
					}
					return false;
				}

				const sessionName = process.env.ZELLIJ_SESSION_NAME;
				const sessionPrefix = sessionName ? ["--session", sessionName] : [];
				const editorCommand = resolveEditorCommand();

				const attempts: Array<{ label: string; args: string[] }> = [
					{
						label: "run",
						args: [...sessionPrefix, "run", "--direction", "down", "--cwd", ctx.cwd, "--", ...editorCommand, filePath],
					},
					{
						label: "action-edit",
						args: [...sessionPrefix, "action", "edit", "--direction", "down", "--cwd", ctx.cwd, filePath],
					},
					{
						label: "edit",
						args: [...sessionPrefix, "edit", "--direction", "down", "--cwd", ctx.cwd, filePath],
					},
				];

				if (sessionPrefix.length > 0) {
					attempts.push({
						label: "run-no-session",
						args: ["run", "--direction", "down", "--cwd", ctx.cwd, "--", ...editorCommand, filePath],
					});
				}

				let lastError = "unknown error";
				for (const attempt of attempts) {
					const result = await pi.exec("zellij", attempt.args, { cwd: ctx.cwd });
					if (result.code === 0) {
						ctx.ui.notify(`Opened in zellij (${attempt.label}): ${filePath}`, "info");
						return true;
					}
					lastError = (result.stderr || result.stdout || `exit ${result.code}`).trim();
				}

				ctx.ui.notify(`Failed to open in zellij: ${lastError}`, "error");
				return false;
			};

			const modelLabel = ctx.model ? `${ctx.model.provider}/${ctx.model.id}` : "no-model";
			let component: ContextOverlayComponent | undefined;

			await ctx.ui.custom<void>(
				(tui, theme, keybindings, done) => {
					component = new ContextOverlayComponent(
						tui,
						theme,
						keybindings,
						store.buildSnapshot(modelLabel),
						() => done(undefined),
						openPathInZellij,
						(message, level) => ctx.ui.notify(message, level ?? "info"),
					);

					const unsubscribe = store.subscribe(() => {
						component?.setSnapshot(store.buildSnapshot(modelLabel));
					});

					return {
						render: (w) => component!.render(w),
						handleInput: (d) => component!.handleInput(d),
						invalidate: () => component!.invalidate(),
						dispose: () => {
							unsubscribe();
							component?.dispose();
						},
					};
				},
				{
					overlay: true,
					overlayOptions: {
						anchor: "center",
						width: "82%",
						maxHeight: "86%",
						margin: 1,
					},
				},
			);
		},
	});
}
