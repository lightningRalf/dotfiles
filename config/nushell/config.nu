# Nushell Configuration
# Fixed version with proper parse-time constant handling

# ===== Environment Loading =====
source ~/.config/nushell/env.nu

# ===== Core Aliases =====
alias ll = ls -la
alias la = ls -a
alias cls = clear
alias .. = cd ..
alias ... = cd ../..
alias .... = cd ../../..

# ===== Git Aliases =====
alias gs = git status
alias ga = git add
alias gc = git commit
alias gp = git push
alias gl = git pull
alias gd = git diff
alias gco = git checkout
alias gb = git branch

# ===== Navigation Functions =====
def --env cdd [] {
    cd $env.DOTFILES_DIR
}

def --env cdh [] {
    cd ~
}

def --env mkcd [dir: path] {
    mkdir $dir
    cd $dir
}

# ===== Platform Detection =====
let is_termux = ($"($env.HOME)/.termux" | path exists)

# ===== Static Script Sourcing =====
# Source integration scripts using static paths
# These scripts should have been generated by env.nu

# Starship prompt
const STARSHIP_SCRIPT = "~/.config/nushell/scripts/starship.nu"
if ($STARSHIP_SCRIPT | path expand | path exists) {
    source ~/.config/nushell/scripts/starship.nu
}

# Zoxide smart cd
const ZOXIDE_SCRIPT = "~/.config/nushell/scripts/zoxide.nu"
if ($ZOXIDE_SCRIPT | path expand | path exists) {
    source ~/.config/nushell/scripts/zoxide.nu
}

# Atuin shell history - ONLY source if file exists
let atuin_script = ($SCRIPTS_DIR | path join "atuin.nu" | path expand)
if ($atuin_script | path exists) {
    print "Loading Atuin integration..."
    source ($atuin_script | str replace '~' $env.HOME)
} else if (which atuin | is-not-empty) {
    print "Atuin is installed but integration script is missing."
    print "To enable Atuin, run: atuin init nu > ~/.config/nushell/scripts/atuin.nu"
}


# ===== Utility Functions =====

# Enhanced ls with automatic detection
def l [path?: path] {
    let target = ($path | default ".")
    if (which exa | is-not-empty) {
        ^exa --icons $target
    } else {
        ls $target
    }
}

# System information summary
def sysinfo [] {
    print $"(ansi yellow_bold)System Information(ansi reset)"
    print "═══════════════════════════"
    
    let host = (sys | get host)
    print $"OS:       ($host.name) ($host.os_version)"
    print $"Kernel:   ($host.kernel_version)"
    print $"Uptime:   ($host.uptime)"
    
    let cpu = (sys | get cpu | first)
    print $"CPU:      ($cpu.brand)"
    print $"Cores:    (sys | get cpu | length)"
    
    let mem = (sys | get mem)
    let mem_pct = (($mem.used / $mem.total * 100) | math round)
    print $"Memory:   ($mem.used | format filesize) / ($mem.total | format filesize) \(($mem_pct)%\)"
}

# Quick file operations
def touch [filename: path] {
    if ($filename | path exists) {
        # Update timestamp
        $filename | path expand | open | save -f $filename
    } else {
        # Create empty file
        "" | save $filename
    }
}

# Find files by pattern
def ff [pattern: string] {
    if (which fd | is-not-empty) {
        ^fd $pattern
    } else {
        ls **/* | where name =~ $pattern | get name
    }
}

# ===== Custom Completions =====

# Directory completion for cd
def "nu-complete dirs" [] {
    ls | where type == "dir" | get name
}

# Git branch completion
def "nu-complete git branches" [] {
    ^git branch -a | lines | each { |line| 
        $line | str trim | str replace '* ' ''
    }
}

# ===== Enhanced Prompt Configuration =====
# Only if starship is not available
if not ($STARSHIP_SCRIPT | path expand | path exists) {
    def create_left_prompt [] {
        let dir = match (do --ignore-shell-errors { $env.PWD | path relative-to $nu.home-path }) {
            null => $env.PWD
            '' => '~'
            $relative_pwd => ([~ $relative_pwd] | path join)
        }

        let path_color = (if (is-admin) { ansi red_bold } else { ansi green_bold })
        let separator_color = (if (is-admin) { ansi light_red_bold } else { ansi light_green_bold })
        let path_segment = $"($path_color)($dir)"

        $path_segment | str replace --all (char path_sep) $"($separator_color)(char path_sep)($path_color)"
    }

    def create_right_prompt [] {
        # Empty right prompt for simplicity
        ""
    }

    $env.PROMPT_COMMAND = {|| create_left_prompt }
    $env.PROMPT_COMMAND_RIGHT = {|| create_right_prompt }
    $env.PROMPT_INDICATOR = {|| "> " }
    $env.PROMPT_INDICATOR_VI_INSERT = {|| ": " }
    $env.PROMPT_INDICATOR_VI_NORMAL = {|| "> " }
    $env.PROMPT_MULTILINE_INDICATOR = {|| "::: " }
}

# ===== Color Theme Configuration =====
let dark_theme = {
    separator: white
    leading_trailing_space_bg: { attr: n }
    header: green_bold
    empty: blue
    bool: light_cyan
    int: white
    duration: white
    filesize: cyan
    date: purple
    range: white
    float: white
    string: white
    nothing: white
    binary: white
    cellpath: white
    row_index: green_bold
    record: white
    list: white
    block: white
    hints: dark_gray
    search_result: { bg: red fg: white }
    shape_and: purple_bold
    shape_binary: purple_bold
    shape_block: blue_bold
    shape_bool: light_cyan
    shape_closure: green_bold
    shape_custom: green
    shape_datetime: cyan_bold
    shape_directory: cyan
    shape_external: cyan
    shape_externalarg: green_bold
    shape_external_resolved: light_cyan_bold
    shape_filepath: cyan
    shape_flag: blue_bold
    shape_float: purple_bold
    shape_garbage: { fg: white bg: red attr: b}
    shape_globpattern: cyan_bold
    shape_int: purple_bold
    shape_internalcall: cyan_bold
    shape_keyword: cyan_bold
    shape_list: cyan_bold
    shape_literal: blue
    shape_match_pattern: green
    shape_matching_brackets: { attr: u }
    shape_nothing: light_cyan
    shape_operator: yellow
    shape_or: purple_bold
    shape_pipe: purple_bold
    shape_range: yellow_bold
    shape_record: cyan_bold
    shape_redirection: purple_bold
    shape_signature: green_bold
    shape_string: green
    shape_string_interpolation: cyan_bold
    shape_table: blue_bold
    shape_variable: purple
    shape_vardecl: purple
    shape_raw_string: light_purple
}

$env.config = ($env.config | merge { color_config: $dark_theme })

# ===== Hooks Configuration =====
$env.config = ($env.config | merge {
    hooks: {
        pre_prompt: [{ ||
            # Could add any pre-prompt logic here
            null
        }]
        pre_execution: [{ ||
            # Could add pre-execution logic here
            null
        }]
        env_change: {
            PWD: [{ |before, after|
                # Could add directory-change logic here
                null
            }]
        }
        display_output: { ||
            # Could modify output display here
            table
        }
    }
})

# ===== Welcome Message =====
if $env.TERM != "dumb" {
    print $"(ansi green_bold)Welcome to Nushell(ansi reset) (version)"
    print $"Configuration loaded successfully | Platform: (if $is_termux { 'Termux' } else { 'Linux' })"
    
    # Quick tips
    print $"(ansi blue)Quick tips:(ansi reset) Try 'sysinfo' for system info, 'ff <pattern>' to find files"
    print ""
}